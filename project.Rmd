
```{r}
library(lubridate)
library(taRifx)
library(ggplot2)
```


## Data set building

```{r}
# Path of the directory for each year for men
years_men_path <- list.dirs(path = '../biathlon_analysis/biathlon_data/men',
                            recursive=FALSE,full.names=TRUE)

# Path of the directory for each year for women
years_women_path <- list.dirs(path='../biathlon_analysis/biathlon_data/women',
                              recursive=FALSE,full.names=TRUE)

# List of years directory names for men
years_men <- list.dirs(path = '../biathlon_analysis/biathlon_data/men', 
                       recursive = FALSE, full.names=FALSE)

# List of years directory names for women
years_women <- list.dirs(path = '../biathlon_analysis/biathlon_data/women', 
                         recursive =FALSE,full.names=FALSE)

# Initializing the list of years present in the data set
years <- c(1:length(years_men))

# Filling the list of years present in the data set
for (i in c(1:length(years_men))){
  
  idx <- unlist(gregexpr('_', years_men[[i]]))
  string <- unlist(strsplit((years_men[[i]]),""))
  final_year <- paste(string[1:idx-1], collapse="")
  years[i] <- final_year
}

```


```{r}
# Initializing the named list of word cup locations
locations <- list()

# Filling the list having as names the year and as values the locations of the word cup venues
for (i in seq_along(years)){

locations[[years[i]]] <- (list.dirs(path = years_men_path[i], recursive = FALSE, full.names = FALSE))
}
# Initializing a list that has to be similar to the previous one but with the full path as values
locations_path_men <- list()

# Same thing for women
locations_path_women <- list()

# Filling the list
for (i in seq_along(years)){

  locations_path_men[[years[i]]] <- (list.dirs(path = years_men_path[i], recursive = FALSE, full.names = TRUE))
}


for (i in seq_along(years)){

  locations_path_women[[years[i]]] <- (list.dirs(path = years_women_path[i], recursive = FALSE, full.names = TRUE))
}
```




```{r}
# Defining a custom infix operator to take the role of the not %in% operator
'%!in%' <- function(a,b) {!( '%in%'(a,b))}
```



```{r}
# Initializing the final data frame of the result of each race
df_results_men <- data.frame()

# Initializing the id of the race
race_id <- 0

# Initializing the count of all the DNS
res_dns_men <- 0

# Initializing the count of all the DSQ
res_dsq_men <- 0

# Initializing the count of all the DNF
res_dnf_men <- 0

# Initializing the count of all the lapped athletes
res_lap_men <- 0

# Initializing the count of all the bibs > 120 because they won't appear in loops, 
# this happens only in Kontiolahti 2014, these damned Finnish...
res_over_men <- 0

# The allowable values for the Rank column of the data frame
allowables <- c(c(1:127), 'DNF', 'DNS', 'DSQ', 'LAP')

# Initializing the list connecting each race to the race_id
list_id_men <- list()


for (i in seq_along(years)){
  for(j in seq_along(locations[[years[i]]])){
    files <- list.files(locations_path_men[[years[i]]],
                  pattern=sprintf('results.%s',locations[[years[i]]][j]),full.names = TRUE )
    # Importing the data frame
    for (file in files){
      
     
      race_id <- race_id + 1
      
      
      df_res <- read.csv(file = file, sep = '\t')
      
      # Raising a flag if the Rank column has not allowable columns
      if(length(df_res$Rank[df_res$Rank %!in% allowables]) !=0){cat('wooow problem, in', file)}
      
      # Updating the count of bibs > 120
      res_over_men <- res_over_men + length(df_res$Rank[destring(df_res$Rank) > 120]
             [! is.na(df_res$Rank[destring(df_res$Rank) > 120])])
      
      # Updating the DNS count
      res_dns_men <- res_dns_men + length(df_res$Rank[df_res$Rank=='DNS'])
      
      # Updating the DNF count
      res_dnf_men <- res_dnf_men + length(df_res$Rank[df_res$Rank=='DNF'])
      
      # Updating the DSQ count
      res_dsq_men <- res_dsq_men + length(df_res$Rank[df_res$Rank=='DSQ'])
      
      # Updating the lapped athletes' count
      res_lap_men <- res_lap_men + length(df_res$Rank[df_res$Rank=='LAP'])
     
      
      # Checking for possible inconsistencies in the data set
      if('Rank' %!in% colnames(df_res)){
        cat(paste('There is a mistake in', file))
      }
      # Adding the isolated.pursuit column to the non-pursuit races in order to have the same
      # columns to perform the rbind operation
      else if('Isolated.Pursuit' %!in% colnames(df_res)){
        df_res$Isolated.Pursuit <- rep(NA, nrow(df_res))
      }

      # Adding the column specifying the year of the race
      df_res$year <- rep(years[i], nrow(df_res))
      # Adding the column specifying the venue of the race
      df_res$location <- rep(locations[[years[i]]][j], nrow(df_res))
      # Adding the column with the id of the race
      df_res$ID <- rep(race_id, nrow(df_res))
      
      # Adding the column specifying the type of the race
      if (grepl(pattern = 'pursuit', x =file, fixed=TRUE)){
        df_res$race_type <- rep('Pursuit', nrow(df_res))
      }
      else if (grepl(pattern = 'individual', x =file, fixed=TRUE)){
        df_res$race_type <- rep('Individual', nrow(df_res))
      }
      else if (grepl(pattern = 'mass_start', x =file, fixed=TRUE)){
        df_res$race_type <- rep('Mass start', nrow(df_res))
      }
      else if (grepl(pattern = 'sprint', x =file, fixed=TRUE)){
        df_res$race_type <- rep('Sprint', nrow(df_res))
      }
      else{
        cat(paste('There is a mistake in',file,
                  'no race type specified'))
      }
      
      # Filling the list connecting the id to the race, the unique identifier for a race has
      # been chosen as a touple, we need also the name of the runner-up because Samuelsson won back
      # to back spring in Oestersund in 2021... Sebastian, I know you are training with Luki right now 
      #but you also # could have avoided being so awesome
      list_id_men[[paste(df_res$race_type[1], years[i], locations[[years[i]]][j], 
                         df_res$Given.Name[1], df_res$Given.Name[2])]] <- race_id
      
      # Updating the final data frame
      df_results_men <- rbind(df_results_men, df_res)
    }
  }
}
```








```{r}
# Initializing the final data frame of the result of each race
df_results_women <- data.frame()

# Initializing the id of the race
race_id <- 0

# Initializing the count of all the DNS
res_dns_women <- 0

# Initializing the count of all the DSQ
res_dsq_women <- 0

# Initializing the count of all the DNF
res_dnf_women <- 0

# Initializing the count of all the lapped athletes
res_lap_women <- 0

# Initializing the count of all the bibs > 120 because they won't appear in loops, 
# this happens only in Kontiolahti 2014, these damned Finnish...
res_over_women <- 0

# The allowable values for the Rank column of the data frame
allowables <- c(c(1:127), 'DNF', 'DNS', 'DSQ', 'LAP')

# Defining the list connectiong races to their id
list_id_women <- list()

for (i in seq_along(years)){
  for(j in seq_along(locations[[years[i]]])){
    files <- list.files(locations_path_women[[years[i]]],
                  pattern=sprintf('results.%s',locations[[years[i]]][j]),full.names = TRUE )
    # Importing the data frame
    for (file in files){
      
      # Updating the race_id that will act as our primary key of the data set
      race_id <- race_id + 1
      
      list_id_women[[file]] <- race_id
      
      df_res <- read.csv(file = file, sep = '\t')
      
      # Raising a flag if the Rank column has not allowable columns
      if(length(df_res$Rank[df_res$Rank %!in% allowables]) !=0){cat('wooow problem, in', file)}
      
      # Updating the count of bibs > 120
      res_over_women <- res_over_women + length(df_res$Rank[destring(df_res$Rank) > 120]
             [! is.na(df_res$Rank[destring(df_res$Rank) > 120])])
      
      # Updating the DNS count
      res_dns_women <- res_dns_women + length(df_res$Rank[df_res$Rank=='DNS'])
      
      # Updating the DNF count
      res_dnf_women <- res_dnf_women + length(df_res$Rank[df_res$Rank=='DNF'])
      
      # Updating the DSQ count
      res_dsq_women <- res_dsq_women + length(df_res$Rank[df_res$Rank=='DSQ'])
      
      # Updating the lapped athletes' count
      res_lap_women <- res_lap_women + length(df_res$Rank[df_res$Rank=='LAP'])
     
      
      # Checking for possible inconsistencies in the data set
      if('Rank' %!in% colnames(df_res)){
        cat(paste('There is a mistake in', file))
      }
      # Adding the isolated.pursuit column to the non-pursuit races in order to have the same
      # columns to perform the rbind operation
      else if('Isolated.Pursuit' %!in% colnames(df_res)){
        df_res$Isolated.Pursuit <- rep(NA, nrow(df_res))
      }

      # Adding the column specifying the year of the race
      df_res$year <- rep(years[i], nrow(df_res))
      # Adding the column specifying the venue of the race
      df_res$location <- rep(locations[[years[i]]][j], nrow(df_res))
      # Adding the column with the id of the race
      df_res$ID <- rep(race_id, nrow(df_res))
      
      # Adding the column specifying the type of the race
      if (grepl(pattern = 'pursuit', x =file, fixed=TRUE)){
        df_res$race_type <- rep('Pursuit', nrow(df_res))
      }
      else if (grepl(pattern = 'individual', x =file, fixed=TRUE)){
        df_res$race_type <- rep('Individual', nrow(df_res))
      }
      else if (grepl(pattern = 'mass_start', x =file, fixed=TRUE)){
        df_res$race_type <- rep('Mass start', nrow(df_res))
      }
      else if (grepl(pattern = 'sprint', x =file, fixed=TRUE)){
        df_res$race_type <- rep('Sprint', nrow(df_res))
      }
      else{
        cat(paste('There is a mistake in',file,
                  'no race type specified'))
      }
      
      # Filling the list as we did for the men, popping out the disqualified is due to the 
      # Glaryzina affair
      list_id_women[[paste(df_res$race_type[1], years[i], locations[[years[i]]][j], 
                         df_res$Given.Name[df_res$Rank %!in% c('DSQ')][1], 
                         df_res$Given.Name[df_res$Rank %!in% c('DSQ')][2])]] <- race_id
      
      # Updating the final data frame
      df_results_women <- rbind(df_results_women, df_res)
    }
  }
}
```



```{r}
head(df_results_women)
```









```{r}
head(df_results_men)
```





```{r}
# Initializing the race_id for the second to last loop data frame
race_id <- 0
# The set of allowable values for the Rank column of the loop data frame
allowables <- c(1:127)
# Initializing the final loop data frame
df_final_loop_men <- data.frame()

# Beginning the cycle that loops over every year and every venue
for (i in seq_along(years)){
  
  for(j in seq_along(locations[[years[i]]])){
    
    
    # All the files that represent a loop in our directory
    files <- list.files(locations_path_men[[years[i]]],
                  pattern=sprintf('loop...%s',locations[[years[i]]][j]),full.names = TRUE )
    
      # Looping over all the files
      for (file in files){
        # Here we select, between all loop files the ones that represent the second to last loop,
        # that is, the loop in which the biathlete arrive at the last shooting range
        if (
            (grepl(pattern = 'pursuit', x =file, fixed=TRUE)  
            &&  
            grepl(pattern = 'loop_4', x =file, fixed=TRUE))
            || 
            (grepl(pattern = 'sprint', x =file, fixed=TRUE)  
             &&  
            grepl(pattern = 'loop_2', x =file, fixed=TRUE))
            || 
            (grepl(pattern = 'individual', x =file, fixed=TRUE)  
             &&  
            grepl(pattern = 'loop_4', x =file, fixed=TRUE))
            || 
            (grepl(pattern = 'mass_start', x =file, fixed=TRUE)  
             &&  
            grepl(pattern = 'loop_4', x =file, fixed=TRUE))
            
            ){
            # Updating the race id
            
            
            # Reading the file into a data frame
            df_loop <- read.csv2(file = file, sep = '\t')
            
            # Here we raise a flag if we don't have the Rank colun in the created data frame
            if('Rank' %!in% colnames(df_loop)){
                cat(paste('There is a mistake in', file, '\n'))
            
            # Here we raise a flag and print the relative fail if we have a Rank value that is not allowed
            if(length(df_loop$Rank[df_loop$Rank %!in% allowables]) !=0){cat('wooow problem, in', file)}
            
            
            } 
            
            # The column Ski.Time is present only on individual races, for tha others we fill it with 0
            # in order to make the rbind possible
            if ('Ski.Time'%!in% colnames(df_loop)){
              df_loop[['Ski.Time']] <- rep(0, nrow(df_loop))
            }
            
            # The Canmore's short individual did not have the Range.Time column, so we create it for the 
            # rbind... but who cares about short individuals anyway!!!
            if ('Range.Time'%!in% colnames(df_loop)){
              df_loop[['Range.Time']] <- rep(0, nrow(df_loop))
            }
            
            # The columns of the data frame
            columns_df <- colnames(df_loop)
            
            # The index from which column regarding times start
            idx_time_columns <- which(columns_df=='Nation')
            
            # The 'time' columns of the table, the -1 at the end is to delete 'Nation'
            # that is not between them
            time_columns <- columns_df[idx_time_columns:length(columns_df)][-1]
            
            # Adding the column specifying the year of the race
            df_loop$year <- rep(years[i], nrow(df_loop))
            
            # Adding the column specifying the venue of the race
            df_loop$location <- rep(locations[[years[i]]][j], nrow(df_loop))
            
           
            
            # Adding the column specifying the type of the race
            if (grepl(pattern = 'pursuit', x =file, fixed=TRUE)){
              df_loop$race_type <- rep('Pursuit', nrow(df_loop))
            }
            else if (grepl(pattern = 'individual', x =file, fixed=TRUE)){
              df_loop$race_type <- rep('Individual', nrow(df_loop))
            }
            else if (grepl(pattern = 'mass_start', x =file, fixed=TRUE)){
              df_loop$race_type <- rep('Mass start', nrow(df_loop))
            }
            else if (grepl(pattern = 'sprint', x =file, fixed=TRUE)){
              df_loop$race_type <- rep('Sprint', nrow(df_loop))
            }
            else{
              cat(paste('There is a mistake in',file,
                        'no race type specified'))
            }
            
            # Assigning to the race the same id that it has on the results data frame
            df_loop$ID <-rep( list_id_men[[paste(df_loop$race_type[1], years[i], locations[[years[i]]][j], 
                         df_loop$Given.Name[1],  df_loop$Given.Name[2])]], nrow(df_loop))
            
            # Initializing the list of the reference times among all the columns, we have in fact that 
            # time columns are note stored as absolute times: we have a reference time and then the other records
            # reference to it as +'time_interval'
            reference_times <- list()
            
            # Looping over all the time columns
            for(column in time_columns){
              
              # In individual races penalty times, as we know, are a thing of their own and the data set
              # itself seem to have noticed! It does not have in fact a value for biathletes that found the
              # 0 in a certain shooting range. We deal with it by giving by default the value 0.
              # We know what you are thinking: What if every one missed at least once?
              # Come on have a little trust in your sport heroes! as soon as Sturla Holm Lægreid will be around
              # we are more them safe!
              if (column == 'Penalty.Time'
                  &&
                  grepl(pattern = 'individual', x = file, fixed=TRUE)
                  )
              {reference_time <- duration(second = 0)}
              
              # In the else statement instead we select as the reference time the record with no '+' in 
              # its body, the [1] is there to arbitrary break the ties between equally good reference times
              else{
                reference_time <- df_loop[[column]][!grepl(pattern = '+', x =df_loop[[column]],
                            fixed=TRUE)]
                }
              reference_time <- reference_time[1]
              
              # In this if cycle we convert the reference time from a string to a time duration
              # thanks to the lubridate package and its duration function
              
              # The first case is for whe we have minutes and not only second where we have a column 
              # as a separator
              if (grepl(pattern = ':', x  = reference_time,
                            fixed=TRUE)){
                
                # Changing the reference time into an iterable
                string_sep <- unlist(strsplit((reference_time),""))
                
                # Getting the index of the column
                idx_sep <- unlist(gregexpr(':', reference_time, fixed = TRUE))
                
                # This step raises a flag if having a double colon signaling hours, 
                # comes out: biathletes are no snails!
                if (length(idx_sep) > 1){cat(paste('Do we have hours now?? in', file  ))}
                
                # The minute part of the reference time
                min <- as.numeric(paste(string_sep[1:idx_sep-1], collapse=""))
                
                # The second part of the reference time
                sec <- as.numeric(paste(string_sep[-c(1:idx_sep)], collapse=""))
                reference_time_ <- duration(minute= min, second=sec)
                
              }
              # This second case is for reference times that don't reach a minute
              else{
                sec <- as.numeric(reference_time)
                reference_time_ <- duration(second=sec)
              }
              
              # Updating the list
              reference_times[[column]] <- reference_time_
              
              # Index of the reference times
              reference_time_idx <- which(!grepl(pattern = '+', x =df_loop[[column]],
                            fixed=TRUE))
              
              # Renaming the times of the current columns
              times_to_add <- df_loop[[column]]
              
              # Initializing the column of the absolute times
              final_adding <- c()
              
              # Filling the final_adding vector
              for (k in seq_along(times_to_add)){
                
                # Putting in the reference times
                if (k %in% reference_time_idx){
                  final_adding[k] <- reference_times[[column]]
                }
                
                # Putting in the 'minutes' recorda
                else if (grepl(pattern = ':', x =times_to_add[k], fixed=TRUE)){
                  string_add <- unlist(strsplit((times_to_add[k]),""))
                  idx_add <- unlist(gregexpr(':', times_to_add[k]))
                  
                  # Flag raise for 'hour' times
                  if (length(idx_add) > 1){print('Do we have hours now?? in', file)} 
                  
                  min_add <- as.numeric(paste(string_add[1:idx_add-1], collapse=""))
                  sec_add <- as.numeric(paste(string_add[-c(1:idx_add)], collapse=""))
                  
                  adding_time <- duration(minute= min_add, second=sec_add)
                  
                  # Here the [1] is present for arbitrarily breaking ties for equally good
                  # reference times
                  final_adding[k] <- adding_time + reference_times[[column]][1]
                }
                else{
                  
                  # The original data frame contained a couple of 'broken' records, being only
                  # the string '+', we changed the values to a known fixed outlier ('+1000') and here
                  # we transform it into NA
                  if (times_to_add[k]=='+1000') {final_adding[k] <- NA}
                  
                  # Non pathological case were we have a 'seconds' time
                  else{
                    final_adding[k] <- duration(second = as.numeric(times_to_add[k])) + 
                      reference_times[[column]]
                  }
                }
                 
              }
              
              # Updating the column of the data frame
              df_loop[[column]] <- final_adding
             
              
            }
            
          # Binding together the data frames  
          df_final_loop_men <- rbind(df_final_loop_men, df_loop)
        
      }
    }
  }
}


```


```{r}
df_final_loop_men
```



```{r}
# Initializing the race_id for the second to last loop data frame
race_id <- 0
# The set of allowable values for the Rank column of the loop data frame
allowables <- c(1:127)
# Initializing the final loop data frame
df_final_loop_women <- data.frame()

# Beginning the cycle that loops over every year and every venue
for (i in seq_along(years)){
  
  for(j in seq_along(locations[[years[i]]])){
    
    
    # All the files that represent a loop in our directory
    files <- list.files(locations_path_women[[years[i]]],
                  pattern=sprintf('loop...%s',locations[[years[i]]][j]),full.names = TRUE )
    
      # Looping over all the files
      for (file in files){
        # Here we select, between all loop files the ones that represent the second to last loop,
        # that is, the loop in which the biathlete arrive at the last shooting range
        if (
            (grepl(pattern = 'pursuit', x =file, fixed=TRUE)  
            &&  
            grepl(pattern = 'loop_4', x =file, fixed=TRUE))
            || 
            (grepl(pattern = 'sprint', x =file, fixed=TRUE)  
             &&  
            grepl(pattern = 'loop_2', x =file, fixed=TRUE))
            || 
            (grepl(pattern = 'individual', x =file, fixed=TRUE)  
             &&  
            grepl(pattern = 'loop_4', x =file, fixed=TRUE))
            || 
            (grepl(pattern = 'mass_start', x =file, fixed=TRUE)  
             &&  
            grepl(pattern = 'loop_4', x =file, fixed=TRUE))
            
            ){
            # Updating the race id
            race_id <- race_id + 1
            
            # Reading the file into a data frame
            df_loop <- read.csv2(file = file, sep = '\t')
            
            # Here we raise a flag if we don't have the Rank colun in the created data frame
            if('Rank' %!in% colnames(df_loop)){
                cat(paste('There is a mistake in', file, '\n'))
            
            # Here we raise a flag and print the relative fail if we have a Rank value that is not allowed
            if(length(df_loop$Rank[df_loop$Rank %!in% allowables]) !=0){cat('wooow problem, in', file)}
            
            
            } 
            
            # The column Ski.Time is present only on individual races, for tha others we fill it with 0
            # in order to make the rbind possible
            if ('Ski.Time'%!in% colnames(df_loop)){
              df_loop[['Ski.Time']] <- rep(0, nrow(df_loop))
            }
            
            # The Canmore's short individual did not have the Range.Time column, so we create it for the 
            # rbind... but who cares about short individuals anyway!!!
            if ('Range.Time'%!in% colnames(df_loop)){
              df_loop[['Range.Time']] <- rep(0, nrow(df_loop))
            }
            
            # The columns of the data frame
            columns_df <- colnames(df_loop)
            
            # The index from which column regarding times start
            idx_time_columns <- which(columns_df=='Nation')
            
            # The 'time' columns of the table, the -1 at the end is to delete 'Nation'
            # that is not between them
            time_columns <- columns_df[idx_time_columns:length(columns_df)][-1]
            
            # Adding the column specifying the year of the race
            df_loop$year <- rep(years[i], nrow(df_loop))
            
            # Adding the column specifying the venue of the race
            df_loop$location <- rep(locations[[years[i]]][j], nrow(df_loop))
            
           
            
            # Adding the column specifying the type of the race
            if (grepl(pattern = 'pursuit', x =file, fixed=TRUE)){
              df_loop$race_type <- rep('Pursuit', nrow(df_loop))
            }
            else if (grepl(pattern = 'individual', x =file, fixed=TRUE)){
              df_loop$race_type <- rep('Individual', nrow(df_loop))
            }
            else if (grepl(pattern = 'mass_start', x =file, fixed=TRUE)){
              df_loop$race_type <- rep('Mass start', nrow(df_loop))
            }
            else if (grepl(pattern = 'sprint', x =file, fixed=TRUE)){
              df_loop$race_type <- rep('Sprint', nrow(df_loop))
            }
            else{
              cat(paste('There is a mistake in',file,
                        'no race type specified'))
            }
            
             # Adding the column with the id of the race
            
            # Assigning to the race the same id that it has on the results data frame
            df_loop$ID <-rep( list_id_women[[paste(df_loop$race_type[1], years[i], locations[[years[i]]][j], 
                         df_loop$Given.Name[df_res$Rank %!in% c('DSQ')][1],  
                         df_loop$Given.Name[df_res$Rank %!in% c('DSQ')][2])]], nrow(df_loop))
            
            # Initializing the list of the reference times among all the columns, we have in fact that 
            # time columns are note stored as absolute times: we have a reference time and then the other records
            # reference to it as +'time_interval'
            reference_times <- list()
            
            # Looping over all the time columns
            for(column in time_columns){
              
              # In individual races penalty times, as we know, are a thing of their own and the data set
              # itself seem to have noticed! It does not have in fact a value for biathletes that found the
              # 0 in a certain shooting range. We deal with it by giving by default the value 0.
              # We know what you are thinking: What if every one missed at least once?
              # Come on have a little trust in your sport heroes! as soon as Sturla Holm Lægreid will be around
              # we are more them safe!
              if (column == 'Penalty.Time'
                  &&
                  grepl(pattern = 'individual', x = file, fixed=TRUE)
                  )
              {reference_time <- duration(second = 0)}
              
              # In the else statement instead we select as the reference time the record with no '+' in 
              # its body, the [1] is there to arbitrary break the ties between equally good reference times
              else{
                reference_time <- df_loop[[column]][!grepl(pattern = '+', x =df_loop[[column]],
                            fixed=TRUE)]
                }
              reference_time <- reference_time[1]
              
              # In this if cycle we convert the reference time from a string to a time duration
              # thanks to the lubridate package and its duration function
              
              # The first case is for whe we have minutes and not only second where we have a column 
              # as a separator
              if (grepl(pattern = ':', x  = reference_time,
                            fixed=TRUE)){
                
                # Changing the reference time into an iterable
                string_sep <- unlist(strsplit((reference_time),""))
                
                # Getting the index of the column
                idx_sep <- unlist(gregexpr(':', reference_time, fixed = TRUE))
                
                # This step raises a flag if having a double colon signaling hours, 
                # comes out: biathletes are no snails!
                if (length(idx_sep) > 1){cat(paste('Do we have hours now?? in', file  ))}
                
                # The minute part of the reference time
                min <- as.numeric(paste(string_sep[1:idx_sep-1], collapse=""))
                
                # The second part of the reference time
                sec <- as.numeric(paste(string_sep[-c(1:idx_sep)], collapse=""))
                reference_time_ <- duration(minute= min, second=sec)
                
              }
              # This second case is for reference times that don't reach a minute
              else{
                sec <- as.numeric(reference_time)
                reference_time_ <- duration(second=sec)
              }
              
              # Updating the list
              reference_times[[column]] <- reference_time_
              
              # Index of the reference times
              reference_time_idx <- which(!grepl(pattern = '+', x =df_loop[[column]],
                            fixed=TRUE))
              
              # Renaming the times of the current columns
              times_to_add <- df_loop[[column]]
              
              # Initializing the column of the absolute times
              final_adding <- c()
              
              # Filling the final_adding vector
              for (k in seq_along(times_to_add)){
                
                # Putting in the reference times
                if (k %in% reference_time_idx){
                  final_adding[k] <- reference_times[[column]]
                }
                
                # Putting in the 'minutes' recorda
                else if (grepl(pattern = ':', x =times_to_add[k], fixed=TRUE)){
                  string_add <- unlist(strsplit((times_to_add[k]),""))
                  idx_add <- unlist(gregexpr(':', times_to_add[k]))
                  
                  # Flag raise for 'hour' times
                  if (length(idx_add) > 1){print('Do we have hours now?? in', file)} 
                  
                  min_add <- as.numeric(paste(string_add[1:idx_add-1], collapse=""))
                  sec_add <- as.numeric(paste(string_add[-c(1:idx_add)], collapse=""))
                  
                  adding_time <- duration(minute= min_add, second=sec_add)
                  
                  # Here the [1] is present for arbitrarily breaking ties for equally good
                  # reference times
                  final_adding[k] <- adding_time + reference_times[[column]][1]
                }
                else{
                  
                  # The original data frame contained a couple of 'broken' records, being only
                  # the string '+', we changed the values to a known fixed outlier ('+1000') and here
                  # we transform it into NA
                  if (times_to_add[k]=='+1000') {final_adding[k] <- NA}
                  
                  # Non pathological case were we have a 'seconds' time
                  else{
                    final_adding[k] <- duration(second = as.numeric(times_to_add[k])) + 
                      reference_times[[column]]
                  }
                }
                 
              }
              
              # Updating the column of the data frame
              df_loop[[column]] <- final_adding
             
              
            }
            
          # Binding together the data frames  
          df_final_loop_women <- rbind(df_final_loop_women, df_loop)
        
      }
    }
  }
}

```



```{r}
head(df_final_loop_women)
```







```{r}
head(df_final_loop_men)
```


```{r}
if(res_dnf_men + res_dns_men + res_dsq_men + res_lap_men + res_over_men + nrow(df_final_loop_men) == nrow(df_results_men)){
  cat('Thank god we no one got lost')
  }else{'Who is missing?!'}
```

```{r}

if(res_dnf_women + res_dns_women + res_dsq_women + res_lap_women + res_over_women + nrow(df_final_loop_women) == nrow(df_results_women)){
  cat('Thank god we no one got lost')
  }else{'Who is missing?!'}
```



## Finding the clutchest biathletes in the word cup




```{r}
# Performing the left join between the 2 men data frames
df_clutch_men <- merge(x=df_results_men,y=df_final_loop_men, by=c('ID', 
                                                                  'location', 'Nation', 'Rank', 'Bib',
                                                                  'Family.Name', 'Given.Name',
                                                                  'year', 'race_type'), all.x=FALSE,
                                                                  all.y=TRUE, sort=FALSE)
```

```{r}
head(df_clutch_men)
```
```{r}
# Performing the two left join for the 2 women data frames
df_clutch_women <- merge(x=df_results_women,y=df_final_loop_women, by=c('ID', 
                                                                  'location', 'Nation', 'Rank', 'Bib',
                                                                  'Family.Name', 'Given.Name',
                                                                  'year', 'race_type'), all.x=FALSE,
                                                                  all.y=TRUE, sort=FALSE)
```



```{r}
head(df_clutch_women)
```

```{r}
# Defining the function to create a column with the number of mistakes in the final range
final_range <- function(x){
  iterable <- unlist(strsplit((x),""))
  return(iterable[length(iterable)])
}

# Creating the 2 columns
df_clutch_men$final_range <- as.numeric(sapply(df_clutch_men$Shootings, final_range))
df_clutch_women$final_range <- as.numeric(sapply(df_clutch_women$Shootings, final_range))
```


For this part of the analysis we consider only head-to-head races, that is, pursuits and mass starts


```{r}
#Defining the data frame with only pursuits and mass starts
df_no_chrono_men <- df_clutch_men[df_clutch_men$race_type %!in% c('Sprint', 'Individual'),]

# The unique ids of the races
unique_ids <- unique(df_no_chrono_men$ID)

# Initializing the data frame with athletes entering the last shooting range in the top ten
df_top10_men <- data.frame()

# Initializing the data frame with athletes entering the last shooting range outside the top ten
df_bottom <- data.frame()

#Looping over the ids
for (id in unique_ids){
  # Identifying the race with each id
  race <- df_no_chrono_men[df_no_chrono_men$ID == id,]
  # Computing the time entering the shooting range
  race$entry_time <- race$Cumulative.Time - race$Range.Time - 
                    race$Penalty.Time
  # We order the race following the entry time record
  race_ord <- race[order(race$entry_time),]
  # Taking only the top 10 rows
  race_add <- race_ord[c(1:10), ]
  # Taking all the records but thew top 10
  race_add_last <- race_ord[c(11:nrow(race_ord)), ]
  # Updating the df_bottom data frame
  df_bottom <- rbind(df_bottom, race_add_last)
  # Updating the f_top10 data frame
  df_top10_men <- rbind(df_top10_men, race_add)
}
```



```{r}
head(df_top10_men)
```

```{r}
head(df_bottom)
```


```{r}
# Creating the column with the full name of the record
df_bottom$full_name <- paste(df_bottom$Family.Name, df_bottom$Given.Name, '')
# Solving the Alexander Loginov problem
df_bottom$full_name[df_bottom$full_name == 'Loginov Alexandr '] <- 'Loginov Alexander '
# Creating the column with the full name of the record
df_top10_men$full_name <- paste(df_top10_men$Family.Name, df_top10_men$Given.Name, '')
# Solving the Alexander Loginov problem
df_top10_men$full_name[df_top10_men$full_name == 'Loginov Alexandr '] <- 'Loginov Alexander '
# Defining the vector of biathletes that have more than 5 top ten appearences
top_names <- names(table(df_top10_men$full_name)[unname(table(df_top10_men$full_name))>=5])
# Selecting only the top names
top_names_top_10 <- df_top10_men[df_top10_men$full_name %in% top_names,]
head(top_names_top_10)
```


```{r}
# Selecting only the athletes in top_names
top_names_bottom <- df_bottom[df_bottom$full_name %in% top_names,]
head(top_names_bottom)
```

Now we want to visualize the most consistent athletes, we plot the percentage of times the top biathletes entered the final shooting range in a top ten position.

```{r}
# The percentage of times each athlete entered the last shooting range in the top 10
# per each athlete
named_percentages <- table(top_names_top_10$full_name)/(table(top_names_top_10$full_name) 
                                   + table(top_names_bottom$full_name))*100

# The actual percentages
percentages <- unname(named_percentages)
# The vector to order the percentages
order_perc <- order(percentages)
```









```{r}
plot <- ggplot() +
        geom_col(aes(x=names(named_percentages) , y=sort(unname(percentages)))) +
        
        scale_x_discrete(labels = names(named_percentages)[order_perc]) +
        
        theme_bw() +
        theme(axis.text.x = element_text(angle = 90)) +
        geom_col(aes(x=31 , y=unname(named_percentages[names(named_percentages)=='Hofer Lukas ']))
                 , fill='blue', color='black') +
        geom_col(aes(x=5 , y=unname(named_percentages[names(named_percentages)=='Windisch Dominik ']))
                 , fill='blue', color='black') +
        geom_col(aes(x=50 , y=unname(named_percentages[names(named_percentages)=='Fourcade Martin ']))
                 , fill='firebrick', color='black') +
        labs(x = '', y = '% of times entering in the top 10', title = 'Concistency of the top biathletes')
plot

```
We see with no surprise how the most consistent biathlete is Martin Fourcade (highlighted in red), not anyone gets the name Monsieur Le Biathlon after all. It comes with quite the surprise though the massive advantage he has with respect to another great as Johannes Thingnes Bø, a whopping 88.7% against 75%. We have to consider though that our data starts from the 2014/2015 season so when Fourcade was already in its prime while Johannes was moving his big but first steps in the word cup. 
In blue we can see the two Italians represented, as we know Luki is by far the most consistent but the infamous echoes of a certain word championship still rings in our ears... CINQUE!

p.s. that Oestersund mass start isn't represented in this part of the analysis as Dominik entered the last shooting range outside the top 10... we all know the ending though.



```{r}
# The data frame that will contain data representing the efficiency
efficiency_df <- data.frame(table(top_names_bottom$full_name), table(top_names_top_10$full_name))
# Eliminating the duplicate of the names
efficiency_df$Var1.1 <- NULL
# Re-defining the column names
colnames(efficiency_df) <- c('Full Names', '# Out top 10', '# In top 10')
head(efficiency_df)
```

```{r}
# Getting the misses in the top 10
miss_top_10 <- aggregate(x = top_names_top_10$final_range, by=list(Names = top_names_top_10$full_name), 
                         FUN = sum)
head(miss_top_10)
```


```{r}
# Misses when approaching not in the top ten
miss_no_top_10 <- aggregate(x = top_names_bottom$final_range, by=list(Names = top_names_bottom$full_name), 
                         FUN = sum)
head(miss_no_top_10)
```




```{r}
# Updating the efficiency df with Misses and attempts
efficiency_df <- cbind(efficiency_df, 'Misses top 10' = miss_top_10$x, 
      'Attempts top 10' = efficiency_df$`# In top 10`*5,
      'Misses not top 10' = miss_no_top_10$x,
      'Attempts no top 10' = efficiency_df$`# Out top 10`*5)
```



```{r}
head(efficiency_df)
```

Now we wanna determine a proper prior, due to its conjugate properties we choose a beta prior. We use a beta having as mean the mean, for each biathlete, of the probability of hitting a shot.
We should be careful though, the last shooting range is always a standing shooting range, so we take the hits and misses only for the last two shots.




```{r}
# Adding the full name to the no_chrono data frame
df_no_chrono_men$full_name <- paste(df_no_chrono_men$Family.Name, df_no_chrono_men$Given.Name, '')

# Function to compute the mistakes in the standing shootings
last_shots <- function(x){
  #Making our string an iterable
  iterable <- unlist(strsplit((x),""))
  #Taking the shots of interest
  string_shots <- iterable[c(5, 7)]
  #Converting the first shot
  first_shot <- as.numeric(string_shots[1])
  # Converting the second shot
  second_shot <- as.numeric(string_shots[2])
  # Returning the total mistakes
  return(first_shot + second_shot)
}

# Making the column with the total misses 
df_no_chrono_men$miss_last_2 <- sapply(X = df_no_chrono_men$Shootings, FUN = last_shots)

# Making the column with the standing precision
df_no_chrono_men$standing_prob <- (10-df_no_chrono_men$miss_last_2)/10
```



```{r}
head(df_no_chrono_men)
```





```{r}
# Total misses for each biathlete over the full data frame
misses <- aggregate(x = df_no_chrono_men$miss_last_2, by = list(Names = df_no_chrono_men$full_name),
                    FUN = sum)$x

# Data frame with the number of occurrences
occ <- as.data.frame(table(df_no_chrono_men$full_name))

# Creating the joint data frame
hit_miss <- cbind(occ, misses)

# Each occurences corresponds to 10 shots
hit_miss$Freq <- hit_miss$Freq*10

# Renaming the shots
colnames(hit_miss) <- c('Names', 'Tot_Attempts', 'Misses')

# Inserting the total attempts
hit_miss$Hits <- hit_miss$Tot_Attempts - hit_miss$Misses

# Inserting the mean probability for each biathlete
hit_miss$Probabilities <- hit_miss$Hits/hit_miss$Tot_Attempts

# Restricting to the atlethes inside the top_names vector
top_names_hit_miss <- hit_miss[hit_miss$Names %in% top_names,]

head(top_names_hit_miss)
```


```{r}
# Computing the standard deviation of the probabilities
std <- aggregate(x = df_no_chrono_men$standing_prob, 
          by = list(Category = df_no_chrono_men$full_name), FUN = sd)

# Restricting to top_names
top_names_std <- std[std$Category %in% top_names,]

# Updating the top_names_hit_miss data frame
top_names_hit_miss$std <- top_names_std$x

head(top_names_hit_miss)
```


```{r}
# The function to compute the alpha of the beta given mean and variance
alpha <- function(mean, sigma){
  return(mean^2*( (1-mean)/(sigma^2) - 1/mean ))
}

# The function to compute the beta of the beta given mean and alpha
beta <- function(alpha, mean){
  return(alpha*((1/mean) - 1))
}
```


```{r}
top_names_hit_miss$alpha <- alpha(mean = top_names_hit_miss$Probabilities, 
                                  sigma = top_names_hit_miss$std)

top_names_hit_miss$beta <- beta(alpha = top_names_hit_miss$alpha, 
                                  mean = top_names_hit_miss$Probabilities)
```


```{r}
head(top_names_hit_miss)
```

```{r}
x_axis <- seq(0, 1, 0.001)
min_idx <- which.min(top_names_hit_miss$Probabilities)
min_prob <- top_names_hit_miss[min_idx,]

max_idx <- 2#which.max(top_names_hit_miss$Probabilities)
max_prob <- top_names_hit_miss[max_idx,]

plot <- ggplot() +
        geom_line(aes(x=x_axis, y=dbeta(x=x_axis, shape1 = min_prob$alpha, shape2 = min_prob$beta),
                                        color = min_prob$Names)) +
        geom_line(aes(x=x_axis, y=dbeta(x=x_axis, shape1 = max_prob$alpha, shape2 = max_prob$beta),
                                        color = max_prob$Names)) +
        theme_bw()
plot
```

```{r}
max_prob
```







